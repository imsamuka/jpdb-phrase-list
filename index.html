<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jpdb Phrase List</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
            crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">

    <style>
        [x-cloak],
        .dsp-none {
            display: none;
        }

        .dotted {
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .small-text {
            font-size: x-small;
        }

        .meanings {
            max-height: 10rem;
            overflow: auto;
            /* text-overflow: ellipsis; */
        }

        .jap {
            font-family: "vkana", "Nunito Sans", "Extra Sans JP", "Noto Sans Symbols2", "Segoe UI", "Noto Sans JP", "Noto Sans CJK JP", "Hiragino Sans GB", "Meiryo", sans-serif;
        }

        .v-text {
            writing-mode: vertical-rl;
            text-transform: full-width;

            max-height: 40vh;
            /* text-overflow: ellipsis; */
            overflow: auto;
        }

        .readButton {
            width: 15px;
            height: 15px;
            display: inline-block;
            margin-left: .5rem;
        }

        .readButton:hover {
            opacity: 0.8
        }

        .markReadButton {
            opacity: 0.1;
            background: url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0icHJlZml4X193LTYgcHJlZml4X19oLTYgcHJlZml4X190ZXh0LWdyYXktODAwIHByZWZpeF9fZGFyazp0ZXh0LXdoaXRlIiBhcmlhLWhpZGRlbj0idHJ1ZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBmaWxsPSJub25lIiB2aWV3Qm94PSIwIDAgMTYgMjAiPjxwYXRoIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIgZD0iTTEgMTdWMmExIDEgMCAwMTEtMWgxMmExIDEgMCAwMTEgMXYxMmExIDEgMCAwMS0xIDFIM2EyIDIgMCAwMC0yIDJ6bTAgMGEyIDIgMCAwMDIgMmgxMk01IDE1VjFtOCAxOHYtNCIvPjwvc3ZnPg==);
            background-size: contain;
            background-repeat: no-repeat;
        }

        .markUnreadButton {
            opacity: 0.4;
            background: url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0icHJlZml4X193LTYgcHJlZml4X19oLTYgcHJlZml4X190ZXh0LWdyYXktODAwIHByZWZpeF9fZGFyazp0ZXh0LXdoaXRlIiBhcmlhLWhpZGRlbj0idHJ1ZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBmaWxsPSJjdXJyZW50Q29sb3IiIHZpZXdCb3g9IjAgMCAxNiAyMCI+PHBhdGggY29sb3I9ImdyZWVuIiBkPSJNMTYgMTRWMmEyIDIgMCAwMC0yLTJIMmEyIDIgMCAwMC0yIDJ2MTVhMyAzIDAgMDAzIDNoMTJhMSAxIDAgMDAwLTJoLTF2LTJhMiAyIDAgMDAyLTJ6TTQgMmgydjEySDRWMnptOCAxNkgzYTEgMSAwIDAxMC0yaDl2MnoiLz48L3N2Zz4=);
            background-size: contain;
            background-repeat: no-repeat;
        }

        .audioButton {
            width: 15px;
            height: 15px;
            display: inline-block;
            margin-left: .5rem;
        }

        .audioButton:hover {
            opacity: 0.8
        }

        .audioIdle {
            opacity: 0.1;
            background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSI+PGRlZnM+PGNsaXBQYXRoIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBpZD0icHJlZml4X19hIj48cmVjdCBzdHlsZT0iaXNvbGF0aW9uOmF1dG87bWl4LWJsZW5kLW1vZGU6bm9ybWFsO3NvbGlkLWNvbG9yOiMwMDA7c29saWQtb3BhY2l0eToxIiB3aWR0aD0iMTkuODczIiBoZWlnaHQ9IjI0Ljg3MyIgeD0iLTIuODgxIiB5PSIuNDY2IiByeD0iOS40MzUiIHJ5PSIuNTgiIGNvbG9yPSIjMDAwIiBvdmVyZmxvdz0idmlzaWJsZSIgb3BhY2l0eT0iLjI5MyIgZmlsbC1vcGFjaXR5PSIuODcxIiBzdHJva2Utd2lkdGg9IjExLjYiLz48L2NsaXBQYXRoPjwvZGVmcz48cGF0aCBkPSJNMTEuODQ1IDI0LjExNGMtLjIxOC0uMDktMS40NTMtMS4yMDgtMi43NDUtMi40ODUtMS4yOTItMS4yNzgtMi43NzgtMi42MDctMy4zMDItMi45NTQtLjg1Ni0uNTY3LTEuMDk2LS42My0yLjM5LS42My0xLjczIDAtMi42Ni0uMzQ4LTMuMDczLTEuMTQ4LS40NDctLjg2Mi0uNDQ3LTcuMzkzIDAtOC4yNTYuNDEzLS44IDEuMzQ0LTEuMTQ3IDMuMDczLTEuMTQ3IDEuMjk0IDAgMS41MzMtLjA2MyAyLjM5Mi0uNjMyLjUyNC0uMzQ3IDIuMDM1LTEuNzAzIDMuMzU2LTMuMDEzIDIuNjE3LTIuNTk1IDMuMDktMi44NTQgNC4yMTgtMi4zMTkgMS4yMzkuNTg4IDEuMjEuMzE5IDEuMjEgMTEuMzYzVjIyLjkybC0uNTg2LjU3MmMtLjYzNy42Mi0xLjUyOS44NzctMi4xNTMuNjJ6bTguMjMzLTMuMTM4Yy0uMjgxLS40MjYtLjUxMi0uODMtLjUxMi0uODk3IDAtLjA2Ny4yMTQtLjI5LjQ3NC0uNDk1Ljc4NS0uNjE4IDIuMDM3LTIuNjY5IDIuNDU1LTQuMDIyIDEuMDA0LTMuMjUuMTc0LTYuNzMyLTIuMjQtOS40MDVsLS43MTEtLjc4Ny41MjMtLjc5LjUyMy0uNzkxLjU1LjM5MmMuODU3LjYxIDIuNDcgMi44ODggMy4wMjcgNC4yNzMgMS41MDYgMy43NS45NDcgNy45NS0xLjQ5IDExLjE5Ny0uNTQyLjcyMy0xLjIzMyAxLjQ5LTEuNTM2IDEuNzA2bC0uNTUuMzkyLS41MTMtLjc3M3ptLTIuMzY1LTMuNTQ4bC0uNTItLjc4Ni41MjItLjc1NGMuNy0xLjAxIDEuMDUyLTIuMDU1IDEuMDUyLTMuMTE5cy0uMzUyLTIuMTA5LTEuMDUyLTMuMTE4bC0uNTIyLS43NTQuNTItLjc4NmMuMzEtLjQ2OC42MjctLjc0Ni43ODMtLjY4Ni4zOS4xNSAxLjU5OSAxLjk5MyAxLjk2NyAzIC40NjUgMS4yNzIuNDMxIDMuNTUtLjA3MyA0Ljg0Ni0uNDA4IDEuMDQ3LTEuNTEzIDIuNjc5LTEuOTMgMi44NS0uMTI1LjA1MS0uNDYtLjI2LS43NDctLjY5M3oiIGNsaXAtcGF0aD0idXJsKCNwcmVmaXhfX2EpIi8+PC9zdmc+);
            background-size: contain;
            background-repeat: no-repeat;
        }

        .audioError {
            opacity: 0.4;
            background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSI+PGRlZnM+PGNsaXBQYXRoIGlkPSJwcmVmaXhfX2EiIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cmVjdCByeT0iLjU4IiByeD0iOS40MzUiIHk9Ii40NjYiIHg9Ii0yLjg4MSIgaGVpZ2h0PSIyNC44NzMiIHdpZHRoPSIxOS44NzMiIHN0eWxlPSJpc29sYXRpb246YXV0bzttaXgtYmxlbmQtbW9kZTpub3JtYWw7c29saWQtY29sb3I6IzAwMDtzb2xpZC1vcGFjaXR5OjEiIGNvbG9yPSIjMDAwIiBvdmVyZmxvdz0idmlzaWJsZSIgb3BhY2l0eT0iLjI5MyIgZmlsbC1vcGFjaXR5PSIuODcxIiBzdHJva2Utd2lkdGg9IjExLjYiLz48L2NsaXBQYXRoPjwvZGVmcz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNi43ODEgLTExMS41KSI+PHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNy41NSAxMTEuMjQ0KSIgY2xpcC1wYXRoPSJ1cmwoI3ByZWZpeF9fYSkiIGQ9Ik0xMS44NDUgMjQuMTE0Yy0uMjE4LS4wOS0xLjQ1My0xLjIwOC0yLjc0NS0yLjQ4NS0xLjI5Mi0xLjI3OC0yLjc3OC0yLjYwNy0zLjMwMi0yLjk1NC0uODU2LS41NjctMS4wOTYtLjYzLTIuMzktLjYzLTEuNzMgMC0yLjY2LS4zNDgtMy4wNzMtMS4xNDgtLjQ0Ny0uODYyLS40NDctNy4zOTMgMC04LjI1Ni40MTMtLjggMS4zNDQtMS4xNDcgMy4wNzMtMS4xNDcgMS4yOTQgMCAxLjUzMy0uMDYzIDIuMzkyLS42MzIuNTI0LS4zNDcgMi4wMzUtMS43MDMgMy4zNTYtMy4wMTMgMi42MTctMi41OTUgMy4wOS0yLjg1NCA0LjIxOC0yLjMxOSAxLjIzOS41ODggMS4yMS4zMTkgMS4yMSAxMS4zNjNWMjIuOTJsLS41ODYuNTcyYy0uNjM3LjYyLTEuNTI5Ljg3Ny0yLjE1My42MnptOC4yMzMtMy4xMzhjLS4yODEtLjQyNi0uNTEyLS44My0uNTEyLS44OTcgMC0uMDY3LjIxNC0uMjkuNDc0LS40OTUuNzg1LS42MTggMi4wMzctMi42NjkgMi40NTUtNC4wMjIgMS4wMDQtMy4yNS4xNzQtNi43MzItMi4yNC05LjQwNWwtLjcxMS0uNzg3LjUyMy0uNzkuNTIzLS43OTEuNTUuMzkyYy44NTcuNjEgMi40NyAyLjg4OCAzLjAyNyA0LjI3MyAxLjUwNiAzLjc1Ljk0NyA3Ljk1LTEuNDkgMTEuMTk3LS41NDIuNzIzLTEuMjMzIDEuNDktMS41MzYgMS43MDZsLS41NS4zOTItLjUxMy0uNzczem0tMi4zNjUtMy41NDhsLS41Mi0uNzg2LjUyMi0uNzU0Yy43LTEuMDEgMS4wNTItMi4wNTUgMS4wNTItMy4xMTlzLS4zNTItMi4xMDktMS4wNTItMy4xMThsLS41MjItLjc1NC41Mi0uNzg2Yy4zMS0uNDY4LjYyNy0uNzQ2Ljc4My0uNjg2LjM5LjE1IDEuNTk5IDEuOTkzIDEuOTY3IDMgLjQ2NSAxLjI3Mi40MzEgMy41NS0uMDczIDQuODQ2LS40MDggMS4wNDctMS41MTMgMi42NzktMS45MyAyLjg1LS4xMjUuMDUxLS40Ni0uMjYtLjc0Ny0uNjkzeiIvPjxyZWN0IHRyYW5zZm9ybT0icm90YXRlKC00NSkiIHJ5PSIuNTY5IiByeD0iMCIgeT0iMTA1LjI5NSIgeD0iLTczLjAzNyIgaGVpZ2h0PSIyLjI1MiIgd2lkdGg9IjkuNjU4IiBzdHlsZT0iaXNvbGF0aW9uOmF1dG87bWl4LWJsZW5kLW1vZGU6bm9ybWFsO3NvbGlkLWNvbG9yOiMwMDA7c29saWQtb3BhY2l0eToxIiBjb2xvcj0iIzAwMCIgb3ZlcmZsb3c9InZpc2libGUiLz48cmVjdCB0cmFuc2Zvcm09InJvdGF0ZSg0NSkiIHJ5PSIuNTM5IiByeD0iMCIgeT0iNjcuMDA4IiB4PSIxMDEuNTIzIiBoZWlnaHQ9IjIuMjUyIiB3aWR0aD0iOS42NTgiIHN0eWxlPSJpc29sYXRpb246YXV0bzttaXgtYmxlbmQtbW9kZTpub3JtYWw7c29saWQtY29sb3I6IzAwMDtzb2xpZC1vcGFjaXR5OjEiIGNvbG9yPSIjMDAwIiBvdmVyZmxvdz0idmlzaWJsZSIvPjwvZz48L3N2Zz4=);
            background-size: contain;
            background-repeat: no-repeat;
        }

        .audioPlaying {
            opacity: 0.8;
            background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSI+PHBhdGggZD0iTTExLjg0NSAyNC4xMTRjLS4yMTgtLjA5LTEuNDUzLTEuMjA4LTIuNzQ1LTIuNDg1LTEuMjkyLTEuMjc4LTIuNzc4LTIuNjA3LTMuMzAyLTIuOTU0LS44NTYtLjU2Ny0xLjA5Ni0uNjMtMi4zOS0uNjMtMS43MyAwLTIuNjYtLjM0OC0zLjA3My0xLjE0OC0uNDQ3LS44NjItLjQ0Ny03LjM5MyAwLTguMjU2LjQxMy0uOCAxLjM0NC0xLjE0NyAzLjA3My0xLjE0NyAxLjI5NCAwIDEuNTMzLS4wNjMgMi4zOTItLjYzMi41MjQtLjM0NyAyLjAzNS0xLjcwMyAzLjM1Ni0zLjAxMyAyLjYxNy0yLjU5NSAzLjA5LTIuODU0IDQuMjE4LTIuMzE5IDEuMjM5LjU4OCAxLjIxLjMxOSAxLjIxIDExLjM2M1YyMi45MmwtLjU4Ni41NzJjLS42MzcuNjItMS41MjkuODc3LTIuMTUzLjYyem04LjIzMy0zLjEzOGMtLjI4MS0uNDI2LS41MTItLjgzLS41MTItLjg5NyAwLS4wNjcuMjE0LS4yOS40NzQtLjQ5NS43ODUtLjYxOCAyLjAzNy0yLjY2OSAyLjQ1NS00LjAyMiAxLjAwNC0zLjI1LjE3NC02LjczMi0yLjI0LTkuNDA1bC0uNzExLS43ODcuNTIzLS43OS41MjMtLjc5MS41NS4zOTJjLjg1Ny42MSAyLjQ3IDIuODg4IDMuMDI3IDQuMjczIDEuNTA2IDMuNzUuOTQ3IDcuOTUtMS40OSAxMS4xOTctLjU0Mi43MjMtMS4yMzMgMS40OS0xLjUzNiAxLjcwNmwtLjU1LjM5Mi0uNTEzLS43NzN6bS0yLjM2NS0zLjU0OGwtLjUyLS43ODYuNTIyLS43NTRjLjctMS4wMSAxLjA1Mi0yLjA1NSAxLjA1Mi0zLjExOXMtLjM1Mi0yLjEwOS0xLjA1Mi0zLjExOGwtLjUyMi0uNzU0LjUyLS43ODZjLjMxLS40NjguNjI3LS43NDYuNzgzLS42ODYuMzkuMTUgMS41OTkgMS45OTMgMS45NjcgMyAuNDY1IDEuMjcyLjQzMSAzLjU1LS4wNzMgNC44NDYtLjQwOCAxLjA0Ny0xLjUxMyAyLjY3OS0xLjkzIDIuODUtLjEyNS4wNTEtLjQ2LS4yNi0uNzQ3LS42OTN6Ii8+PC9zdmc+);
            background-size: contain;
            background-repeat: no-repeat;
        }

        .audioLoading {
            opacity: 0.6;
            background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQiIGNsYXNzPSJwcmVmaXhfX3ByZWZpeF9fbGRzLXJvbGxpbmciIHN0eWxlPSJhbmltYXRpb24tcGxheS1zdGF0ZTpydW5uaW5nO2FuaW1hdGlvbi1kZWxheTowcztiYWNrZ3JvdW5kOjAgMCI+PGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMjgyOTJmIiBzdHJva2Utd2lkdGg9IjEwIiByPSIzNSIgc3Ryb2tlLWRhc2hhcnJheT0iMTY0LjkzNCA1Ni45NzgiIHRyYW5zZm9ybT0icm90YXRlKDE4IDUwIDUwKSIgc3R5bGU9ImFuaW1hdGlvbi1wbGF5LXN0YXRlOnJ1bm5pbmc7YW5pbWF0aW9uLWRlbGF5OjBzIj48YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InJvdGF0ZSIgY2FsY01vZGU9ImxpbmVhciIgdmFsdWVzPSIwIDUwIDUwOzM2MCA1MCA1MCIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49IjBzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIvPjwvY2lyY2xlPjwvc3ZnPg==);
            background-size: contain;
            background-repeat: no-repeat;
        }
    </style>


    <script>
        // all this is mostly from https://sentencesearch.neocities.org/

        playingButtons = {};

        function audioOnClick(target) {
            target.addClass = (c) => target.classList.add(c)
            target.removeClass = (c) => target.classList.remove(c)

            var audioURL = target.href;
            var playingId = audioURL;

            if (playingButtons[playingId]) {
                // audio is already playing
                var audio = playingButtons[playingId];
                togglePause(audio);

            } else {

                // create new audio and add all the necessary listeners
                var audio = new Audio(audioURL);
                playingButtons[playingId] = audio;

                audio.onplaying = () => showPlaying(target);
                audio.onpause = () => showIdle(target);
                audio.onloadstart = () => showLoading(target);
                audio.onloadeddata = () => showIdle(target);

                audio.onended = () => {
                    delete playingButtons[playingId];
                    showIdle(target);
                };

                audio.onerror = () => {
                    delete playingButtons[playingId];
                    showError(target);
                };

                audio.play();
            }
            return false;
        }

        function togglePause(audio) {
            if (audio.paused && audio.currentTime > 0 && !audio.ended) {
                audio.play();
            } else {
                audio.pause();
            }
        }


        function showPlaying(button) {
            button.addClass("audioPlaying");
            button.removeClass("audioIdle");
            button.removeClass("audioLoading");
        }

        function showIdle(button) {
            button.addClass("audioIdle");
            button.removeClass("audioPlaying");
            button.removeClass("audioLoading");
        }

        function showError(button) {
            button.addClass("audioError");
            button.removeClass("audioLoading");
            button.removeClass("audioIdle");
            button.removeClass("audioPlaying");
        }

        function showLoading(button) {
            button.addClass("audioLoading");
            button.removeClass("audioIdle");
        }
    </script>

    <script>
        // https://stackoverflow.com/a/73096001

        // return how many bytes the UTF-16 code unit `s` would be, if represented in utf8
        function utf8_len(s) {
            var charCode = s.charCodeAt(0);
            if (charCode < 128) return 1;
            if (charCode < 2048) return 2;
            if ((55296 <= charCode) && (charCode <= 56319)) return 4; // UTF-16 high surrogate
            if ((56320 <= charCode) && (charCode <= 57343)) return 0; // UTF-16 low surrogate
            if (charCode < 65536) return 3;
            throw 'Bad char';
        }

        // Returns the substring of `str` starting at UTF-8 byte index `startInBytes`,
        // that extends for `lengthInBytes` UTF-8 bytes. May misbehave if the
        // specified string does NOT start and end on character boundaries.
        function substr_utf8_bytes(str, startInBytes, lengthInBytes) {
            var currCharIdx = 0;

            // Scan through the string, looking for the start of the substring
            var bytePos = 0;
            while (bytePos < startInBytes) {
                var utf8Len = utf8_len(str.charAt(currCharIdx));
                bytePos += utf8Len;
                currCharIdx++;

                // Make sure to include low surrogate
                if ((utf8Len == 4) && (bytePos == startInBytes)) {
                    currCharIdx++;
                }
            }

            // We've found the substring; copy it to resultStr character by character
            var resultStr = '';
            var currLengthInBytes = 0;
            while (currLengthInBytes < lengthInBytes) {
                var utf8Len = utf8_len(str.charAt(currCharIdx));
                currLengthInBytes += utf8Len;
                resultStr += str[currCharIdx];
                currCharIdx++;

                // Make sure to include low surrogate
                if ((utf8Len == 4) && (currLengthInBytes == lengthInBytes)) {
                    resultStr += str[currCharIdx];
                }
            }

            return resultStr;
        }
    </script>

    <script>
        // https://stackoverflow.com/a/23329386
        function bytesOfString(str) {
            var s = str.length;
            for (var i = str.length - 1; i >= 0; i--) {
                var code = str.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff) s++;
                else if (code > 0x7ff && code <= 0xffff) s += 2;
                if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
            }
            return s;
        }

        function mbOfStored(key) {
            return bytesOfString(localStorage.getItem(key) || "") / 1_000_000
        }

        function insertAtIndex(str, substring, index) {
            return str.slice(0, index) + substring + str.slice(index)
        }

        function b64_to_bytes(base64) {
            const binString = atob(base64);
            return Uint8Array.from(binString, (m) => m.codePointAt(0));
        }
        function bytes_to_b64(bytes) {
            const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
            return btoa(binString);
        }
        async function blob_to_b64(blob) {
            return bytes_to_b64(new Uint8Array(await blob.arrayBuffer()))
        }


        async function gzBlob_to_obj(gzBlob) {
            const stream = gzBlob.stream().pipeThrough(new DecompressionStream('gzip'))
            return await (await new Response(stream)).json()
        }
        async function gzb64_to_obj(gzb64) {
            return await gzBlob_to_obj(new Blob([b64_to_bytes(gzb64)]))
        }
        async function obj_to_gzBlob(obj) {
            const blob = new Blob([JSON.stringify(obj)], { type: 'application/json' })
            const stream = blob.stream().pipeThrough(new CompressionStream("gzip"))
            return await (await new Response(stream)).blob()
        }
        async function obj_to_gzb64(obj) {
            return await blob_to_b64(await obj_to_gzBlob(obj))
        }

        const api_url = "https://jpdb.io/api/v1"
        const sentences_file = (
            "https://corsproxy.io/?" + encodeURIComponent(
                "https://paste.c-net.org/MosesTubby"));
        const audio_url_base = "https://receptomanijalogi.web.app/audio/"
        const parse_max_length = 100
        const card_states = {
            "due": "Due",
            "known": "Known",
            "learning": "Learning",
            "new": "New",
            "failed": "Failed",
            "locked": "Locked",
            // "blacklisted": "Blacklisted", // all particles are marked as blacklisted
            // "never-forget": "Never Forget",
            // "redundant": "Redundant",
        }
        const save_session = ['api_key']
        const save_local = [
            // need $watch workaround
            'selected_sources',
            'memory_level',
            'unknown_words',
            'include_card_state',
            'exclude_card_state',
            // safe
            'min_char',
            'max_char',
            // shouldn't be cleared on reset_filters
            'vertical_text',
            'furigana_on_unknown',
            'furigana_everywhere',
            'reveal_everything',
            'hide_already_read',
            'reveal_marks_read',
            'combine_history',
        ]
        const save_local_compressed = ['vocabs', 'cached_tokens', 'read_history_hor', 'read_history_ver']


        let state = {}
        let lrev = 0
        let revhist = []


        document.addEventListener('alpine:init', async () => (Alpine.data('state', () => ({
            api_key: "",
            ping_result: 1,

            sentences: [],
            sources: [],

            read_history_hor: {}, // {sentences_index: timestamp}
            read_history_ver: {}, // {sentences_index: timestamp}

            // Is pretty persistent; but updated each time
            vocabs: {}, // {'vid/sid': [...vocab, timestamp]}

            // used directly when the user requests the sentences
            tokens: [], // [sentences_index, [[vid, sid], timestamp, ...sentence_token[1:]]]
            // used only when API is not available (i.e no internet)
            cached_tokens: {},

            // local filters
            min_char: 1,
            max_char: 0,
            selected_sources: ["jlpt-tango/n5"],
            // with_query: "",


            // jpdb filters
            include_card_state: [],
            exclude_card_state: ["locked"],
            memory_level: 1,
            unknown_words: "ignore", // number of vocabulary words that will be ignored by the other filters

            vertical_text: false,
            furigana_on_unknown: false,
            furigana_everywhere: false,
            reveal_everything: false,
            hide_already_read: false,
            reveal_marks_read: false,
            combine_history: false,


            load_sentences(sentences) {
                this.sentences = Object.freeze(sentences)
                this.sources = Object.freeze(sentences.reduce((a, s) => {
                    if (!a.includes(s.source)) a.push(s.source); return a;
                }, []))
            },

            get_read_history(si) {
                if (this.combine_history) {
                    return this.read_history_ver[si] || this.read_history_hor[si]
                } else {
                    return this.vertical_text ? this.read_history_ver[si] : this.read_history_hor[si]
                }
            },
            toggle_read_history(si, value = undefined) {
                if (value !== undefined) { value = !value }
                if (this.combine_history) {
                    if (value ?? this.get_read_history(si)) {
                        delete this.read_history_ver[si]
                        delete this.read_history_hor[si]
                    } else {
                        const obj = this.vertical_text ? this.read_history_ver : this.read_history_hor
                        obj[si] = new Date().getTime()
                    }
                } else {
                    const obj = this.vertical_text ? this.read_history_ver : this.read_history_hor
                    if (value ?? obj[si]) { delete obj[si] } else { obj[si] = new Date().getTime() }
                }
            },

            reset_filters() {
                save_local.slice(0, 7).forEach((k) => localStorage.removeItem(k));
                location.reload()
            },

            async ask_api(path, body) {
                try {
                    return await fetch(api_url + path, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.api_key}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(body || {})
                    })
                } catch (e) {
                    console.error('API Error:', e);
                    return new Response(
                        JSON.stringify({ error: "unknown", error_message: e }),
                        { status: 400 })
                }
            },

            api_key_valid() {
                return /^[A-Za-z0-9]{32}$/.test(this.api_key)
            },

            async ping_api(force) {
                if (this.ping_result === 6) {
                    while (this.ping_result === 6) {
                        await new Promise((resolve) => setTimeout(() => resolve(), 100));
                    }
                } else if (!this.api_key) {
                    this.ping_result = 1
                } else if (force || this.ping_result <= 5) {
                    this.ping_result = 6
                    const res = await this.ask_api("/ping")
                    this.ping_result = res ? res.status : 2
                    console.log(`Tested API ping. Status: ${this.ping_result} | Body: "${res && await res.text()}"`)
                }

                return this.ping_result
            },

            local_filtered({ on_cache = false, never_before = false, unread = false, random = false, sort_read = false, end = 0 } = {}) {
                // TODO: 'with_query'
                if (never_before) unread = true
                if (unread) sort_read = false
                let indexes = this.sentences
                    .map((s, i) => [s, i])
                    .filter(([s, i]) => (
                        (!never_before || !(i in this.cached_tokens)) &&
                        (!unread || !((i in this.read_history_hor) || (i in this.read_history_ver))) &&
                        (!on_cache || (i in this.cached_tokens)) &&
                        (this.min_char <= s.jap.length) &&
                        (this.max_char === 0 || this.max_char >= s.jap.length) &&
                        (this.selected_sources.length === 0 || this.selected_sources.includes(s.source)) &&
                        (s.jap.length > 0 && s.eng.length > 0)
                    ))
                    .map(([s, i]) => i)
                if (random) indexes.sort(() => .5 - Math.random())
                if (end) indexes = indexes.slice(0, end)
                if (sort_read) indexes.sort((si1, si2) => (
                    (this.get_read_history(si1) ? 1 : -1) -
                    (this.get_read_history(si2) ? 1 : -1)
                ));
                return indexes
            },

            local_cached_filtered(end) {
                const indexes = this.local_filtered(
                    { on_cache: true, unread: true, random: true, end }
                )
                if (indexes.length < parse_max_length) {
                    indexes = indexes.concat(indexes, this.local_filtered(
                        { on_cache: true, random: true, sort_read: true, end: end - indexes.length }
                    ))
                }
                return indexes
            },

            async gather_cached_sentences() {
                const indexes = this.local_cached_filtered(parse_max_length)
                this.tokens = indexes.map((i) => [i, this.cached_tokens[i]])
            },

            async gather_sentences() {
                if (this.ping_result != 200) {
                    console.log("Ping returned a error before. Not gathering sentences")
                    return
                }

                let indexes = this.local_filtered({ never_before: true, random: true, end: parse_max_length })
                const exhausted_filters = indexes.length < parse_max_length

                // TODO: remove this probably?
                if (exhausted_filters) {
                    indexes = indexes.concat(indexes, this.local_cached_filtered(parse_max_length - indexes.length))
                }

                if (indexes.length === 0) {
                    console.log("No new sentences to download using the current Local Filters.")
                }

                console.log("Gathering sentences...")

                const text = indexes.map((i) => this.sentences[i]["jap"])
                const res = await this.ask_api("/parse", {
                    "text": text,
                    "token_fields": ["vocabulary_index", "position", "length", "furigana"],
                    "position_length_encoding": "utf16",
                    "vocabulary_fields": [
                        "vid",
                        "sid",
                        "card_level",
                        "card_state",
                        "reading",
                        "spelling",
                        "frequency_rank",
                        "meanings",
                        // "meanings_part_of_speech"
                    ]
                })
                const { error, error_message, tokens, vocabulary } = await res.json()
                const now = new Date().getTime()

                if (error) {
                    console.error(`API returned error '${error}': ${error_message}`)
                    return
                }

                const new_tokens = tokens.map(
                    (token, ti) => [indexes[ti], token.map((chunk) => {
                        const vocab = vocabulary[chunk[0]]
                        const nmt = chunk.slice(1)
                        nmt.unshift(vocab.slice(0, 2).join("/"), now)
                        return nmt
                    })])

                this.tokens = new_tokens

                Object.assign(this.vocabs, Object.fromEntries(
                    vocabulary.map((v) => [`${v[0]}/${v[1]}`, [...v, now]])))

                Object.assign(this.cached_tokens, Object.fromEntries(new_tokens))
                console.log("Gathering finished...")
            },

            is_known_tk([vid_sid]) {
                const vocab = this.vocabs[vid_sid]
                if (!vocab) {
                    // console.error(`"${vid_sid}" vocab is undefined`)
                    return true
                }

                // both may be null
                const card_level = vocab[2] || 0
                const card_state = vocab[3] || []

                return (
                    // these are always known
                    card_state.includes('never-forget') ||
                    card_state.includes('blacklisted') ||
                    this.memory_level <= card_level &&
                    (this.include_card_state.length === 0 ||
                        card_state.every(s => this.include_card_state.includes(s) ||
                            ['never-forget', 'blacklisted', 'redundant'].includes(s))) &&
                    (this.exclude_card_state.length === 0
                        || !card_state.some(s => this.exclude_card_state.includes(s)))
                )
            },

            show_token_vocabs(s_tokens) {
                return s_tokens
                    .map(([vid_sid]) => this.vocabs[vid_sid])
                    .filter((vocab) => {
                        const card_state = vocab[3] || []
                        return !(
                            card_state.includes('never-forget') ||
                            card_state.includes('blacklisted')
                        )
                    })
            },

            unknown_token_words(s_tokens) {
                return s_tokens.map(tk => this.is_known_tk(tk)).reduce((acc, k) => acc + !k, 0)
            },

            tokens_ruby(s_tokens, s_index, fopen) {
                let jap = this.sentences[s_index].jap
                // let data = { fopen: [] }

                function furigana_words_length(furis, i) {
                    return furis.slice(i).reduce((acc, el) => (
                        acc + (Array.isArray(el) ? el[0] : el).length
                    ), 0)
                }

                s_tokens.slice().reverse().forEach(([vid_sid, timestamp, spos, slen, furis]) => {
                    if (!furis) return // furis === null
                    furis = furis.slice().reverse()
                    const known = this.is_known_tk([vid_sid])

                    const oi = fopen.push(false) - 1

                    for (const [i, furi] of furis.entries()) {
                        const has_furi = Array.isArray(furi)

                        const pos = spos + furigana_words_length(furis, i + 1)
                        const len = has_furi ? furi[0].length : furi.length

                        const with_opt = `reveal_everything || reveal || furigana_everywhere || (furigana_on_unknown && ${!known} /* unknown */)`
                        const open_det = `(${with_opt} || fopen[${oi}])`

                        jap = insertAtIndex(jap, `</ruby>`, pos + len)
                        if (has_furi) {
                            const rp = `<rp x-transition.duration.300ms x-show="${open_det}">`
                            const rt = `<rt x-transition.duration.300ms x-show="${open_det}">`
                            jap = insertAtIndex(jap, `${rp}(</rp>${rt}${furi[1]}</rt>${rp})</rp>`, pos + len)
                        }
                        jap = insertAtIndex(jap, `<ruby :class="${open_det} ? '' : 'fw-bold'" @click="if (!${with_opt}) {fopen[${oi}] = !fopen[${oi}]}">`, pos)
                    }
                })
                jap = jap.split("\n").join("<br>")

                return `<span sentence_index="${s_index}" class="jap" lang="jp">${jap}</span>`
            },


            sentence_audio_url(s_index) {
                const url = (this.sentences[s_index] || {}).audio_jap || ""
                try {
                    return new URL(url, audio_url_base).toString()
                } catch (e) {
                    console.error("Failed to make audio URL: ", e)
                    return ""
                }
            },

            // {sentences_index: [vid_sid, timestamp, position, length, furigana]}

            //         "vocabulary_fields": [
            //             "vid",
            //             "sid",
            //             "card_level",
            //             "card_state",
            //             "reading",
            //             "spelling",
            //             "frequency_rank",
            //             "meanings",
            //             // "meanings_part_of_speech",
            //             "timestamp"
            //         ]

            // <template x-for="(s_tokens, i) in tokens">
            //             <div class="col">
            //                 <div class="h-100 card">
            //                     <div class="card-body row text-center fs-3">
            //                         <p>
            //                             <template x-for="s_token in s_tokens">

            clear_tokens() {
                this.tokens = []
            },

            async ping_api_result() {
                return {
                    1: "No API Key",
                    2: "Unknown Error",
                    200: "Working",
                    403: "Unauthorized",
                    420: "Too Many Requests"
                }[await this.ping_api()] || "Unknown"
            },

            async ping_api_result_badge() {
                return {
                    1: "text-bg-secondary",
                    2: "text-bg-danger",
                    200: "text-bg-success",
                    403: "text-bg-danger",
                    420: "text-bg-danger"
                }[await this.ping_api()] || "text-bg-warning"
            },

            async downloadSentences(failures = 0) {
                try {
                    console.log("Trying to download sentences...")
                    const res = await fetch(sentences_file)
                    if (!res.ok) throw new Error(`Failed to fetch the file. Status: ${res.status}`)
                    const gzBlob = await res.blob()
                    console.log(`Downloaded ${this.sentences.length} sentences`)
                    this.load_sentences(await gzBlob_to_obj(gzBlob))
                    localStorage.setItem('sentences', await blob_to_b64(gzBlob))

                } catch (error) {
                    console.error("Failed to fetch the sentences file:", error);
                    const secs = parseInt(Math.min(250 * 2 ** failures, 60000))
                    console.log(`Failed ${failures} times. Trying again in ${secs}ms`)
                    setTimeout(() => this.downloadSentences(failures + 1), secs)
                }
            },

            async init() {
                state = this

                try {
                    // console.log(`Loading 'sentences' from localStorage`);
                    if (!Object.keys(localStorage).includes('sentences'))
                        throw "value doesn't exist"
                    this.load_sentences(await gzb64_to_obj(localStorage.getItem('sentences')))
                    console.log(`Loaded ${this.sentences.length} sentences`)
                } catch (e) {
                    console.error("Failed to load saved sentences:", e)
                    await this.downloadSentences()
                }

                for (const k of save_session) {
                    if (Object.keys(sessionStorage).includes(k)) {
                        this[k] = JSON.parse(sessionStorage.getItem(k))
                        console.log(`Loaded '${k}' from sessionStorage`);
                    } else {
                        console.log(`Failed to load '${k}' from sessionStorage: value doesn't exist`)
                    }
                }
                for (const k of save_local) {
                    if (Object.keys(localStorage).includes(k)) {
                        this[k] = JSON.parse(localStorage.getItem(k))
                        console.log(`Loaded '${k}' from localStorage`);
                    } else {
                        console.log(`Failed to load '${k}' from localStorage: value doesn't exist`)
                    }
                }
                for (const k of save_local_compressed) {
                    try {
                        // console.log(`Loading '${k}' from localStorage (compressed)`);
                        if (!Object.keys(localStorage).includes(k)) {
                            // throw "value doesn't exist"
                            console.log(`Failed to load '${k}' from localStorage (compressed): value doesn't exist`)
                            continue
                        }
                        this[k] = await gzb64_to_obj(localStorage.getItem(k))
                        console.log(`Loaded '${k}' from localStorage (compressed)`);
                    } catch (e) {
                        console.error(`Failed to load saved '${k}':`, e)
                    }
                }

                // I absolutely hate this..
                // Dynamically populated Select Options don't have a good
                // support of defaults, they clean and always selects the first
                // So i abuse the $watch here to re-colocate the defaults
                const needs = save_local.slice(0, 5)
                const saved = Object.fromEntries(needs.map(k => [k, this[k]]))
                Object.assign(this, Object.fromEntries(needs.map(k => [k, null])))

                save_session.forEach((k) => this.$watch(k, v => {
                    console.log(`Saving '${k}' on sessionStorage`);
                    sessionStorage.setItem(k, JSON.stringify(v))
                }));
                save_local.forEach((k) => this.$watch(k, v => {
                    console.log(`Saving '${k}' on localStorage`);
                    // if (k == "reveal_everything") {
                    //     revhist.push(performance.now() - lrev)
                    //     console.log(revhist.reduce((ac, c) => ac + c, 0) / revhist.length)
                    // }
                    localStorage.setItem(k, JSON.stringify(v))
                }))
                save_local_compressed.forEach((k) => this.$watch(k, async v => {
                    console.log(`Saving '${k}' on localStorage (compressed)`);
                    localStorage.setItem(k, await obj_to_gzb64(v))
                }))

                Object.assign(this, saved)

                this.gather_cached_sentences()
            }
        }))))
    </script>
</head>

<body class="dark mb-5" x-data="state">
    <div class="container mt-3">
        <div class="row justify-content-md-center"> <!-- row-cols-1 row-cols-md-2 -->
            <div class="col col-md-10 col-lg-8 col-xl-6">
                <div class="row mb-3">
                    <h2 class="mt-4 text-center">jpdb.io Sentence Reader</h2>
                </div>

                <div class="row mb-3 align-items-end">
                    <div class="accordion" id="config_accordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse-api" aria-expanded="false"
                                        aria-controls="collapse-api">API Configuration</button>
                            </h2>
                            <div id="collapse-api" class="accordion-collapse collapse"
                                 data-bs-parent="#config_accordion">
                                <div class="accordion-body col">
                                    <div class="row text-center mb-2">
                                        <h5>API Status: <span class="badge" :class="await ping_api_result_badge()"
                                                  x-text="ping_api_result">No API Key</span></h5>
                                    </div>

                                    <div class="input-group has-validation">
                                        <div class="form-floating"
                                             :class="api_key_valid() ? '' : 'is-invalid'">
                                            <input type="password" class="form-control"
                                                   :class="api_key_valid() ? '' : 'is-invalid'"
                                                   id="api_key" x-model.lazy.debounce.1000ms="api_key"
                                                   placeholder="JPDB API key" required>
                                            <label for="api_key">JPDB API key</label>
                                        </div>
                                        <button class="btn btn-outline-secondary" @click.debounce.500ms="ping_api(true)"
                                                :disabled="!api_key_valid()"
                                                type="button">Ping API</button>
                                        <div class="invalid-feedback">Supply the API Key from your <a class="link-dark"
                                               href="https://jpdb.io/settings">jpdb.io Settings</a> page.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse-local" aria-expanded="false"
                                        aria-controls="collapse-local">Local Filters</button>
                            </h2>
                            <div id="collapse-local" class="accordion-collapse collapse"
                                 data-bs-parent="#config_accordion">
                                <div class="accordion-body row row-cols-sm-2 row-cols-1 align-items-end">
                                    <!-- <div class="search-bar mb-2">
                                            <input type="text" x-model.debounce.100ms="with_query" class="form-control"
                                            placeholder="Show Phrases Containing..."></div>
                                    -->
                                    <div class="col mb-3">
                                        <!-- <label class="form-label">Character Count</label> -->
                                        <div class="input-group mb-3">
                                            <span class="input-group-text">Minimum Characters</span>
                                            <input type="number" x-model.number.debounce.500ms="min_char" min="1"
                                                   aria-label="Minimum Characters" class="form-control">
                                        </div>
                                        <div class="input-group">
                                            <span class="input-group-text">Maximum Characters</span>
                                            <input type="number" x-model.number.debounce.500ms="max_char" min="0"
                                                   aria-label="Maximum Characters" class="form-control">
                                        </div>
                                    </div>
                                    <div class="col mb-3">
                                        <label for="input_selected_sources" class="form-label">Sentence Sources</label>
                                        <select id="input_selected_sources" multiple class="form-select"
                                                x-model.lazy.debounce.500ms="selected_sources"
                                                aria-label="Sentence Sources">
                                            <template x-for="source in sources">
                                                <option x-text="source"></option>
                                            </template>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse-jpdb" aria-expanded="false"
                                        aria-controls="collapse-jpdb">What's considered Known</button>
                            </h2>
                            <div id="collapse-jpdb" class="accordion-collapse collapse"
                                 data-bs-parent="#config_accordion">
                                <div class="accordion-body">

                                    <div class="row">
                                        <div class="col mb-3">
                                            <div class="input-group">
                                                <label class="input-group-text"
                                                       for="memory_level">Min Memory Level</label>
                                                <select class="form-select" id="memory_level"
                                                        x-model.number.debounce.500ms="memory_level">
                                                    <template x-for="i in 8">
                                                        <option x-text="i-1"></option>
                                                    </template>
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="row mb-3">
                                        <div class="col">
                                            <label for="input_include_card_state"
                                                   class="form-label">Included Card States</label>
                                            <select id="input_include_card_state" multiple class="form-select"
                                                    x-model.lazy.debounce.500ms="include_card_state"
                                                    aria-label="Included Card States">
                                                <template x-for="(title, key) in card_states">
                                                    <option x-text="title" :value="key"></option>
                                                </template>
                                            </select>
                                        </div>
                                        <div class="col">
                                            <label for="input_exclude_card_state"
                                                   class="form-label">Excluded Card States</label>
                                            <select id="input_exclude_card_state" multiple class="form-select"
                                                    x-model.lazy.debounce.500ms="exclude_card_state"
                                                    aria-label="Excluded Card States">
                                                <template x-for="(title, key) in card_states">
                                                    <option x-text="title" :value="key"></option>
                                                </template>
                                            </select>
                                        </div>
                                    </div>



                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse-actions" aria-expanded="false"
                                        aria-controls="collapse-actions">
                                    Actions
                                </button>
                            </h2>
                            <div id="collapse-actions" class="accordion-collapse collapse"
                                 data-bs-parent="#config_accordion">
                                <div class="accordion-body">
                                    <div class="row justify-content-center g-2">
                                        <div class="col-auto">
                                            <button @click.debounce="reset_filters" class="btn btn-outline-secondary"
                                                    type="button">Reset Filters</button>
                                        </div>
                                        <div class="col-auto">
                                            <button @click.debounce="cached_tokens = {}" class="btn btn-outline-warning"
                                                    type="button">Clear Cache</button>
                                        </div>
                                        <div class="col-auto">
                                            <button @click.debounce="read_history_hor = {}"
                                                    class="btn btn-outline-warning"
                                                    type="button">Clear Hor. Read History</button>
                                        </div>
                                        <div class="col-auto">
                                            <button @click.debounce="read_history_ver = {}"
                                                    class="btn btn-outline-warning"
                                                    type="button">Clear Ver. Read History</button>
                                        </div>
                                        <div class="col-auto">
                                            <button @click.debounce="downloadSentences()"
                                                    class="btn btn-outline-primary"
                                                    type="button">(Re)Download Sentences</button>
                                        </div>
                                        <div class="col-auto">
                                            <button @click.debounce="localStorage.removeItem('sentences'); location.reload()"
                                                    class="btn btn-outline-danger"
                                                    type="button">Delete Sentences</button>
                                        </div>
                                    </div>

                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse-stats" aria-expanded="false"
                                        aria-controls="collapse-stats">
                                    Stats
                                </button>
                            </h2>
                            <div id="collapse-stats" class="accordion-collapse collapse"
                                 data-bs-parent="#config_accordion">
                                <div class="accordion-body">
                                    <ul
                                        class="list-group list-group-flush">
                                        <li class="list-group-item"
                                            x-text="`Total Sentences: ${sentences.length} (${
                                                mbOfStored('sentences').toFixed(2)}MB)`">
                                            Total Sentences: ?</li>
                                        <li class="list-group-item"
                                            x-text="`Sentences With Local Filters: ${local_filtered().length}`">
                                            Sentences With Local Filters: ?</li>
                                        <li class="list-group-item"
                                            x-text="`Sentences With Local Filters present in cache: ${local_filtered({on_cache: true}).length}`">
                                            Sentences With Local Filters present in cache: ?</li>
                                        <li class="list-group-item"
                                            x-text="`Cached Tokens: ${Object.keys(cached_tokens).length} (${
                                                mbOfStored('cached_tokens').toFixed(2)}MB)`">
                                            Cached Tokens: ?</li>
                                        <li class="list-group-item"
                                            x-text="`Cached Vocabularies: ${Object.keys(vocabs).length} (${
                                                mbOfStored('vocabs').toFixed(2)}MB)`">
                                            Cached Vocabularies: ?</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <div class="row justify-content-center">
                    <button class="btn btn-success btn-lg w-auto mt-3"
                            x-bind:disabled="!(api_key_valid() && ping_result === 200)"
                            @click.debounce.1000="await gather_sentences()">Get Sentences</button>
                </div>
                <div class="row justify-content-center">
                    <button class="btn btn-link link-dark btn-sm w-auto mt-1 mb-3"
                            x-bind:disabled="!local_filtered({on_cache: true}).length"
                            @click.debounce.1000="await gather_cached_sentences()">Use from Cache</button>
                </div>

                <div class="row gap-3 px-4 justify-content-center align-items-center">

                    <div class="col-auto">
                        <div class="form-check form-check-inline form-switch">
                            <input class="form-check-input" type="checkbox" id="v_txt"
                                   x-model.debounce.50ms="vertical_text">
                            <label class="form-check-label" for="v_txt">Vertical Text</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="comb_history"
                                   x-model.debounce.100ms="combine_history">
                            <label class="form-check-label" for="comb_history">Combine Hor./Ver. History</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="hide_read"
                                   x-model.debounce.100ms="hide_already_read">
                            <label class="form-check-label" for="hide_read">Hide Already Read</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="reveal_as_read"
                                   x-model.debounce.100ms="reveal_marks_read">
                            <label class="form-check-label" for="reveal_as_read">Reveal marks as Read</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="furi_unk"
                                   x-model.debounce.100ms="furigana_on_unknown">
                            <label class="form-check-label" for="furi_unk">Furigana on Unknown</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="furi_every"
                                   x-model.debounce.100ms="furigana_everywhere">
                            <label class="form-check-label" for="furi_every">Furigana Everywhere</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="reveal_every"
                                   x-model.debounce.100ms="reveal_everything">
                            <label class="form-check-label" for="reveal_every">Reveal Everything</label>
                        </div>
                    </div>

                    <div class="col-auto">
                        <div class="input-group">
                            <label class="input-group-text"
                                   for="unknown_words">Max Unknown Words</label>
                            <select class="form-select" id="unknown_words"
                                    x-model.number.debounce.100ms="unknown_words">
                                <option value="ignore">Disabled</option>
                                <template x-for="i in 11">
                                    <option x-text="i-1"></option>
                                </template>
                            </select>
                        </div>
                    </div>

                </div>

                <!--  .debounce.200ms <div class="row justify-content-center">
                    <label for="input_sorting" class="form-label">Sort Method</label>
                    <select id="input_sorting" class="form-select"
                            x-model.lazy.debounce.500ms="sorting"
                            aria-label="Sort Method">
                            <option value="random">Random</option>
                            <option value="easiest">Easiest</option>
                            <option value="hardest">Hardest</option>
                            <option value="smallest">Smallest</option>
                            <option value="largest">Largest</option>
                    </select>
                </div> -->
            </div>
        </div>

        <hr>

        <div class="row">
            <div class="col">
                <div class="row">
                    <button class="btn btn-link link-underline-opacity-0 btn-lg link-secondary w-auto my-1"
                            x-text="`Collected ${Object.keys(tokens).length} sentences - Click to clear`"
                            @click.debounce.1000="clear_tokens()">Collected 0 sentences - Click to clear</button>
                </div>

                <div class="row row-cols-1 row-cols-sm-2 row-cols-lg-4 g-2">
                    <template x-for="[si, s_tokens] in tokens">
                        <div class="col" x-transition.opacity.duration.400ms
                             x-show="(!hide_already_read || !get_read_history(si)) && (unknown_words === 'ignore' || unknown_words >= unknown_token_words(s_tokens))">
                            <div class="h-100 card" x-data="{ fopen: [], reveal: false }">
                                <div class="card-body row row justify-content-center">
                                    <p class="fs-4 mb-0" :class="vertical_text ? 'v-text mx-0 w-auto' : 'text-center'"
                                       x-html="tokens_ruby(s_tokens, si, fopen)"></p>

                                    <div class="row p-0 align-items-center">
                                        <div class="col-auto p-0 lh-1 ms-2">
                                            <a :href="sentence_audio_url(si)"
                                               class="p-3 m-0 audioButton audioIdle "
                                               onclick="audioOnClick(this); return false;"
                                               title="Play sound"></a>
                                        </div>
                                        <div class="col p-0">
                                            <hr class="my-1">
                                        </div>
                                        <div class="col-auto p-0 lh-1 ms-2">
                                            <a :title="get_read_history(si) ? 'Mark Unread' : 'Mark Read'"
                                               class="p-3 m-0 readButton"
                                               :class="get_read_history(si) ? 'markUnreadButton' : 'markReadButton'"
                                               @click="toggle_read_history(si)" href="javascript:void(0);"></a>
                                        </div>
                                    </div>


                                    <button class="btn btn-secondary w-25 my-1" style="height: fit-content;"
                                            x-transition:enter.duration.500ms x-show="!(reveal_everything || reveal)"
                                            @click="reveal = true; if (reveal_marks_read) { toggle_read_history(si, true) }">Reveal</button>

                                    <div x-transition:enter.duration.500ms x-show="reveal_everything || reveal">

                                        <p class="text-center fs-4 mb-2"
                                           x-html="sentences[si].eng.split('\n').join('<br>')"></p>

                                        <ul class="fs-5 mb-0 ps-3 meanings">
                                            <template x-for="vocab in show_token_vocabs(s_tokens)">
                                                <li>
                                                    <ruby>
                                                        <a :href="`https://jpdb.io/vocabulary/${vocab[0]}/${vocab[5]}`"
                                                           class="link-primary link-underline-opacity-0"
                                                           x-text="vocab[5]"></a>
                                                        <rp x-show="vocab[4] != vocab[5]">(</rp>
                                                        <rt x-show="vocab[4] != vocab[5]" x-text="vocab[4]"></rt>
                                                        <rp x-show="vocab[4] != vocab[5]">)</rp>
                                                    </ruby>

                                                    <span class="badge rounded-pill text-bg-secondary small-text"
                                                          x-text="`Top ${vocab[6]}`"></span>

                                                    <ol class="fs-6 ps-3">
                                                        <template x-for="meaning in vocab[7]">
                                                            <li x-text="meaning"></li>
                                                        </template>
                                                    </ol>
                                                </li>
                                            </template>
                                        </ul>
                                    </div>

                                    <!-- meanings_part_of_speech = vocab[8] -->

                                </div>
                            </div>
                        </div>
                    </template>
                </div>

            </div>

        </div>


        <!-- <button :class="'my-3 w-25 mx-auto  btn btn-lg ' + (open ? 'btn-secondary' : 'btn-primary')"
                @click="open = !open" x-text="open ? 'Hide' : 'Show'"></button> -->
        <!-- <div class="row" x-show="false">
            <h2 class="mb-3 mt-4 text-center">Available Phrases</h2>

        <div x-show="open" class="row row-cols-auto g-1">
            <template x-for="key_sentence of sentences">
                <div class="col">
                    <div class="card" x-data="{ spelling: false }">
                        <div class="card-body link-underline-opacity-0">
                            <a class="card-text" x-text="key_sentence[1]"
                                :href="'https://tatoeba.org/en/sentences/show/' + key_sentence[0]"></a>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
    </div> -->

    </div>
</body>

</html>
